# This is a template file to define the behaviour and look of the studiocontroller webgui.
# It contains some sample buttons/(GPI), the Mikrotik comands (scriptps) that will be called
# when that button is pressed, and also the user defined status fields that relay information back to the user
# that will be displayed on the studiocontroller webgui

# It is a dictionary of keys and values encoded in json format (see here: https://en.wikipedia.org/wiki/JSON)
# which is a list of comma seperated 'keys' with their values, all enclosed in curly brackets
# The keys themselves should be in double quotes, seperated from the values by a colon
# Values that a strings should also be in double quotes. Numeric values do not need quotes
# To denote 'no value', use the word null
# Note: strings containing double quotes within the string itseld can be handled by prefacing the double quote with a
# '\' character. So for instance, the Mikrotik command :put "$[/system clock get time]" when written into json would be
# ":put \"$[/system clock get time]\"",

#
# Values can themselves also be 'nested' dictionaries of key: value pairs (once again, comma seperated, and enclosed
# in curly brackets. So, for instance the buttons and user fields
#
# Comment lines (those that start with a hash) will be ignored
#
#  The outer keys are:
# "deviceSshUsername": The ssh username that will be used to log into the Mikrotik router
# "deviceAddress": The ip address of the Mikrotik router
# "buttonScriptMappings": A dictionary of keys: values that define a button on the web page, and what the button does
# "statusFieldMappings": A dictionary of keys: values that define a status field on the web page, and where the field
#                          gets its data from
#
# buttonScriptMappings
# --------------------
# A list of buttons, their corresponding ssh command strings and the id of the field
# that will be populated with the response of that command
# "label": The label that will be displayed on the html button
# "target_cmd_string": The command string that will be sent to the device (via SSH)
# "response_field_id": Optional javascript html dom ID where the result/output of the command will be displayed
#                       This maps directly to the "id" field in the statusFieldMappings definitions
#
# statusFieldMappings
# -------------------
# A list of labelled status fields that can be populated automatically by the output of the
# ssh command string contained in target_cmd_string. Polling will occur at a period set by polling_interval_ms
# If "target_cmd_string" and polling_interval_ms are initialised as None, they will be ignored and *wont* be set
# to auto poll (but these field id's will still have been created so can be modified on the page)"
# "label" The text that will be displayed beside the field
# "target_cmd_string" (optional) The command string that will automatically be sent to the device (via SSH) at a period
#                       specified in "polling_interval_ms". Note: If this key is not to be used, (i.e if this field will
#                       just be used to diaplay the output from a command triggered by a button, use the value null)
#
#
# "id" A unique label used by html/javascript to uniquely identify the field within the web page
#       The device response to the command string in "target_cmd_string" will be displayed in this field
# "polling_interval_ms" The period in (in mS) that the command string defined in "target_cmd_string" will be sent
#                       This permits the automatic retrieval of a value at a preset interval. If "target_cmd_string" is
#                        not used (i.e null) this should also be set to null

# Example statusFieldMappings definitions
# {
#               "label": "Current cmd status",
#                 "target_cmd_string": null,
#                 "id": "cmd_response",
#                 "polling_interval_ms": null
#             },
#             {
#                 "label": "Current Router Clock",
#                 "target_cmd_string": ":put \"$[/system clock get time]\"",
#                 "id": "uTik_timeOfDay",
#                 "polling_interval_ms": 5000
#             },

{
        "deviceAddress": "192.168.3.2",
        "deviceSshUsername": "kabulctrl",
        "buttonScriptMappings": [
            {
                "label": "Route via 4G",
                "target_cmd_string": "system script run route_via_4g",
                "response_field_id": null
            },
            {
                "label": "Route via adhoc WiFi",
                "target_cmd_string": "system script run route_via_adhoc_wifi",
                "response_field_id": null
            },
            {
                "label": "Route via adhoc cabled connection",
                "target_cmd_string": "system script run route_via_adhoc_cable",
                "response_field_id": null
            },
            {
                "label": "Get Router Identity",
                "target_cmd_string": "system script run get_identity",
                "response_field_id": "cmd_response"
            }
        ],
        "statusFieldMappings": [
            {
                "label": "Current Routing status",
                "target_cmd_string": "system script run get_current_routing",
                "id": "uTik_current_route",
                "polling_interval_ms": 5000
            }
        ]
}
